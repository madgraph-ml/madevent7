from __future__ import annotations
import pybind11_stubgen.typing_ext
import typing
__all__ = ['AlphaSGrid', 'BatchSize', 'ChannelWeightNetwork', 'Context', 'CutItem', 'Cuts', 'DataType', 'Decay', 'Device', 'Diagram', 'DifferentialCrossSection', 'DiscreteFlow', 'DiscreteSampler', 'EnergyScale', 'EventGenerator', 'EventGeneratorConfig', 'EventGeneratorStatus', 'FastRamboMapping', 'Flow', 'Function', 'FunctionBuilder', 'FunctionGenerator', 'FunctionRuntime', 'Instruction', 'InstructionCall', 'Integrand', 'Invariant', 'LineRef', 'Luminosity', 'MLP', 'Mapping', 'MatrixElement', 'MatrixElementApi', 'MomentumPreprocessing', 'MultiChannelMapping', 'PartonDensity', 'PdfGrid', 'PhaseSpaceMapping', 'Propagator', 'PropagatorChannelWeights', 'RunningCoupling', 'TPropagatorMapping', 'Tensor', 'Topology', 'TwoParticleDecay', 'TwoParticleScattering', 'Type', 'Unweighter', 'Value', 'VegasGridOptimizer', 'VegasMapping', 'batch_float', 'batch_four_vec', 'batch_int', 'batch_size', 'batch_sizes', 'cpu_device', 'cuda_device', 'default_context', 'default_cuda_context', 'float', 'format_progress', 'format_si_prefix', 'format_with_error', 'initialize_vegas_grid', 'int', 'set_lib_path', 'set_thread_count', 'single_float', 'single_int']
class AlphaSGrid:
    def __init__(self, file: str) -> None:
        ...
    def coefficients_shape(self, batch_dim: bool = False) -> list[int]:
        ...
    def logq2_shape(self, batch_dim: bool = False) -> list[int]:
        ...
    @property
    def logq2(self) -> list[float]:
        ...
    @property
    def q(self) -> list[float]:
        ...
    @property
    def q_count(self) -> int:
        ...
    @property
    def region_sizes(self) -> list[int]:
        ...
    @property
    def values(self) -> list[float]:
        ...
class BatchSize:
    one: typing.ClassVar[BatchSize]  # value = 1
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, name: str) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
class ChannelWeightNetwork(FunctionGenerator):
    def __init__(self, channel_count: int, particle_count: int, hidden_dim: int = 32, layers: int = 3, activation: MLP.Activation = MLP.Activation.Activation.leaky_relu, prefix: str = '') -> None:
        ...
    def mlp(self) -> MLP:
        ...
    def preprocessing(self) -> MomentumPreprocessing:
        ...
class Context:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, device: Device) -> None:
        ...
    def define_global(self, name: str, dtype: DataType, shape: list[int], requires_grad: bool = False) -> Tensor:
        ...
    def device(self) -> Device:
        ...
    def get_global(self, name: str) -> Tensor:
        ...
    def global_exists(self, name: str) -> bool:
        ...
    def global_requires_grad(self, name: str) -> bool:
        ...
    def load(self, file: str) -> None:
        ...
    def load_matrix_element(self, file: str, param_card: str) -> int:
        ...
    def matrix_element(self, index: int) -> MatrixElementApi:
        ...
    def save(self, file: str) -> None:
        ...
class CutItem:
    def __init__(self, observable: Cuts.CutObservable, limit_type: Cuts.LimitType, value: float, pids: list[int]) -> None:
        ...
    @property
    def limit_type(self) -> Cuts.LimitType:
        ...
    @property
    def observable(self) -> Cuts.CutObservable:
        ...
    @property
    def pids(self) -> list[int]:
        ...
    @property
    def value(self) -> float:
        ...
class Cuts:
    class CutObservable:
        """
        Members:
        
          obs_pt
        
          obs_eta
        
          obs_dr
        
          obs_mass
        
          obs_sqrt_s
        """
        __members__: typing.ClassVar[dict[str, Cuts.CutObservable]]  # value = {'obs_pt': <CutObservable.obs_pt: 0>, 'obs_eta': <CutObservable.obs_eta: 1>, 'obs_dr': <CutObservable.obs_dr: 2>, 'obs_mass': <CutObservable.obs_mass: 3>, 'obs_sqrt_s': <CutObservable.obs_sqrt_s: 4>}
        obs_dr: typing.ClassVar[Cuts.CutObservable]  # value = <CutObservable.obs_dr: 2>
        obs_eta: typing.ClassVar[Cuts.CutObservable]  # value = <CutObservable.obs_eta: 1>
        obs_mass: typing.ClassVar[Cuts.CutObservable]  # value = <CutObservable.obs_mass: 3>
        obs_pt: typing.ClassVar[Cuts.CutObservable]  # value = <CutObservable.obs_pt: 0>
        obs_sqrt_s: typing.ClassVar[Cuts.CutObservable]  # value = <CutObservable.obs_sqrt_s: 4>
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    class LimitType:
        """
        Members:
        
          min
        
          max
        """
        __members__: typing.ClassVar[dict[str, Cuts.LimitType]]  # value = {'min': <LimitType.min: 0>, 'max': <LimitType.max: 1>}
        max: typing.ClassVar[Cuts.LimitType]  # value = <LimitType.max: 1>
        min: typing.ClassVar[Cuts.LimitType]  # value = <LimitType.min: 0>
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    bottom_pids: typing.ClassVar[list] = [-5, 5]
    jet_pids: typing.ClassVar[list] = [1, 2, 3, 4, -1, -2, -3, -4, 21]
    lepton_pids: typing.ClassVar[list] = [11, 13, 15, -11, -13, -15]
    max: typing.ClassVar[Cuts.LimitType]  # value = <LimitType.max: 1>
    min: typing.ClassVar[Cuts.LimitType]  # value = <LimitType.min: 0>
    missing_pids: typing.ClassVar[list] = [12, 14, 16, -12, -14, -16]
    obs_dr: typing.ClassVar[Cuts.CutObservable]  # value = <CutObservable.obs_dr: 2>
    obs_eta: typing.ClassVar[Cuts.CutObservable]  # value = <CutObservable.obs_eta: 1>
    obs_mass: typing.ClassVar[Cuts.CutObservable]  # value = <CutObservable.obs_mass: 3>
    obs_pt: typing.ClassVar[Cuts.CutObservable]  # value = <CutObservable.obs_pt: 0>
    obs_sqrt_s: typing.ClassVar[Cuts.CutObservable]  # value = <CutObservable.obs_sqrt_s: 4>
    photon_pids: typing.ClassVar[list] = [22]
    def __init__(self, pids: list[int], cut_data: list[CutItem]) -> None:
        ...
    def build_function(self, builder: FunctionBuilder, sqrt_s: Value, momenta: Value) -> list[Value]:
        ...
    def eta_max(self) -> list[float]:
        ...
    def pt_min(self) -> list[float]:
        ...
    def sqrt_s_min(self) -> float:
        ...
class DataType:
    """
    Members:
    
      int
    
      float
    
      batch_sizes
    """
    __members__: typing.ClassVar[dict[str, DataType]]  # value = {'int': <DataType.int: 0>, 'float': <DataType.float: 1>, 'batch_sizes': <DataType.batch_sizes: 2>}
    batch_sizes: typing.ClassVar[DataType]  # value = <DataType.batch_sizes: 2>
    float: typing.ClassVar[DataType]  # value = <DataType.float: 1>
    int: typing.ClassVar[DataType]  # value = <DataType.int: 0>
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class Decay:
    @property
    def child_indices(self) -> list[int]:
        ...
    @property
    def index(self) -> int:
        ...
    @property
    def mass(self) -> float:
        ...
    @property
    def parent_index(self) -> int:
        ...
    @property
    def width(self) -> float:
        ...
class Device:
    pass
class Diagram:
    def __init__(self, incoming_masses: list[float], outgoing_masses: list[float], propagators: list[Propagator], vertices: list[list[LineRef]]) -> None:
        ...
    @property
    def incoming_masses(self) -> list[float]:
        ...
    @property
    def incoming_vertices(self) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    @property
    def outgoing_masses(self) -> list[float]:
        ...
    @property
    def outgoing_vertices(self) -> list[int]:
        ...
    @property
    def propagator_vertices(self) -> list[list[int]]:
        ...
    @property
    def propagators(self) -> list[Propagator]:
        ...
    @property
    def vertices(self) -> list[list[LineRef]]:
        ...
class DifferentialCrossSection(FunctionGenerator):
    def __init__(self, pid_options: list[list[int]], matrix_element_index: int, running_coupling: RunningCoupling, pdf_grid: PdfGrid | None, e_cm2: float, energy_scale: EnergyScale, simple_matrix_element: bool = True, channel_count: int = 1, amp2_remap: list[int] = []) -> None:
        ...
    def pid_options(self) -> list[list[int]]:
        ...
class DiscreteFlow(Mapping):
    def __init__(self, option_counts: list[int], prefix: str = '', dims_with_prior: list[int] = [], condition_dim: int = 0, subnet_hidden_dim: int = 32, subnet_layers: int = 3, subnet_activation: MLP.Activation = MLP.Activation.Activation.leaky_relu) -> None:
        ...
    def condition_dim(self) -> int:
        ...
    def initialize_globals(self, context: Context) -> None:
        ...
    def option_counts(self) -> list[int]:
        ...
class DiscreteSampler(Mapping):
    def __init__(self, option_counts: list[int], prefix: str = '', dims_with_prior: list[int] = []) -> None:
        ...
    def initialize_globals(self, context: Context) -> None:
        ...
class EnergyScale(FunctionGenerator):
    class DynamicScaleType:
        """
        Members:
        
          transverse_energy
        
          transverse_mass
        
          half_transverse_mass
        
          partonic_energy
        """
        __members__: typing.ClassVar[dict[str, EnergyScale.DynamicScaleType]]  # value = {'transverse_energy': <DynamicScaleType.transverse_energy: 0>, 'transverse_mass': <DynamicScaleType.transverse_mass: 1>, 'half_transverse_mass': <DynamicScaleType.half_transverse_mass: 2>, 'partonic_energy': <DynamicScaleType.partonic_energy: 3>}
        half_transverse_mass: typing.ClassVar[EnergyScale.DynamicScaleType]  # value = <DynamicScaleType.half_transverse_mass: 2>
        partonic_energy: typing.ClassVar[EnergyScale.DynamicScaleType]  # value = <DynamicScaleType.partonic_energy: 3>
        transverse_energy: typing.ClassVar[EnergyScale.DynamicScaleType]  # value = <DynamicScaleType.transverse_energy: 0>
        transverse_mass: typing.ClassVar[EnergyScale.DynamicScaleType]  # value = <DynamicScaleType.transverse_mass: 1>
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    half_transverse_mass: typing.ClassVar[EnergyScale.DynamicScaleType]  # value = <DynamicScaleType.half_transverse_mass: 2>
    partonic_energy: typing.ClassVar[EnergyScale.DynamicScaleType]  # value = <DynamicScaleType.partonic_energy: 3>
    transverse_energy: typing.ClassVar[EnergyScale.DynamicScaleType]  # value = <DynamicScaleType.transverse_energy: 0>
    transverse_mass: typing.ClassVar[EnergyScale.DynamicScaleType]  # value = <DynamicScaleType.transverse_mass: 1>
    @typing.overload
    def __init__(self, particle_count: int) -> None:
        ...
    @typing.overload
    def __init__(self, particle_count: int, type: EnergyScale.DynamicScaleType) -> None:
        ...
    @typing.overload
    def __init__(self, particle_count: int, fixed_scale: float) -> None:
        ...
    @typing.overload
    def __init__(self, particle_count: int, dynamic_scale_type: EnergyScale.DynamicScaleType, ren_scale_fixed: bool, fact_scale_fixed: bool, ren_scale: float, fact_scale1: float, fact_scale2: float) -> None:
        ...
class EventGenerator:
    default_config: typing.ClassVar[EventGeneratorConfig]  # value = <madevent7._madevent_py.EventGeneratorConfig object>
    integrand_flags: typing.ClassVar[int] = 21
    def __init__(self, context: Context, channels: list[Integrand], file_name: str, default_config: EventGeneratorConfig = ..., temp_file_dir: str | None = None) -> None:
        ...
    def channel_status(self) -> list[EventGeneratorStatus]:
        ...
    def generate(self) -> None:
        ...
    def status(self) -> EventGeneratorStatus:
        ...
    def survey(self) -> None:
        ...
class EventGeneratorConfig:
    max_batch_size: int
    max_overweight_fraction: float
    max_overweight_truncation: float
    optimization_patience: int
    optimization_threshold: float
    start_batch_size: int
    survey_max_iters: int
    survey_min_iters: int
    survey_target_precision: float
    target_count: int
    vegas_damping: float
    def __init__(self) -> None:
        ...
class EventGeneratorStatus:
    count: int
    count_target: float
    count_unweighted: float
    done: bool
    error: float
    index: int
    iterations: int
    mean: float
    rel_std_dev: float
    def __init__(self) -> None:
        ...
class FastRamboMapping(Mapping):
    def __init__(self, n_particles: int, massless: bool) -> None:
        ...
class Flow(Mapping):
    def __init__(self, input_dim: int, condition_dim: int = 0, prefix: str = '', bin_count: int = 10, subnet_hidden_dim: int = 32, subnet_layers: int = 3, subnet_activation: MLP.Activation = MLP.Activation.Activation.leaky_relu, invert_spline: bool = True) -> None:
        ...
    def condition_dim(self) -> int:
        ...
    def initialize_globals(self, context: Context) -> None:
        ...
    def input_dim(self) -> int:
        ...
class Function:
    @staticmethod
    def load(file: str) -> Function:
        ...
    def __call__(self, *args):
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def store(self, file: str) -> None:
        ...
    @property
    def globals(self) -> dict[str, Value]:
        ...
    @property
    def inputs(self) -> list[Value]:
        ...
    @property
    def instructions(self) -> list[InstructionCall]:
        ...
    @property
    def locals(self) -> list[Value]:
        ...
    @property
    def outputs(self) -> list[Value]:
        ...
class FunctionBuilder:
    def __init__(self, input_types: list[Type], output_types: list[Type]) -> None:
        ...
    def add(self, in1: Value, in2: Value) -> Value:
        ...
    def batch_cat(self, args: list[Value]) -> typing.Annotated[list[Value], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    def batch_gather(self, indices: Value, values: Value) -> Value:
        ...
    def batch_size(self, args: list[Value]) -> Value:
        ...
    def batch_split(self, in: Value, counts: Value) -> list[Value]:
        ...
    def boost_beam(self, p1: Value, x1: Value, x2: Value) -> Value:
        ...
    def boost_beam_inverse(self, p1: Value, x1: Value, x2: Value) -> Value:
        ...
    def breit_wigner_invariant(self, r: Value, mass: Value, width: Value, s_min: Value, s_max: Value) -> typing.Annotated[list[Value], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    def breit_wigner_invariant_inverse(self, s: Value, mass: Value, width: Value, s_min: Value, s_max: Value) -> typing.Annotated[list[Value], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    def cat(self, args: list[Value]) -> Value:
        ...
    def chili_forward(self, r: Value, e_cm: Value, m_out: Value, pt_min: Value, y_max: Value) -> typing.Annotated[list[Value], pybind11_stubgen.typing_ext.FixedSize(4)]:
        ...
    def collect_channel_weights(self, amp2: Value, channel_indices: Value, channel_count: Value) -> Value:
        ...
    def com_p_in(self, e_cm: Value) -> typing.Annotated[list[Value], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    def cut_dr(self, p: Value, indices: Value, min_max: Value) -> Value:
        ...
    def cut_eta(self, p: Value, min_max: Value) -> Value:
        ...
    def cut_m_inv(self, p: Value, indices: Value, min_max: Value) -> Value:
        ...
    def cut_pt(self, p: Value, min_max: Value) -> Value:
        ...
    def cut_sqrt_s(self, p: Value, min_max: Value) -> Value:
        ...
    def cut_unphysical(self, w_in: Value, p: Value, x1: Value, x2: Value) -> Value:
        ...
    def diff_cross_section(self, x1: Value, x2: Value, pdf1: Value, pdf2: Value, matrix_element: Value, e_cm2: Value) -> Value:
        ...
    def fast_rambo_massive(self, r: Value, e_cm: Value, masses: Value, p0: Value) -> typing.Annotated[list[Value], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    def fast_rambo_massive_com(self, r: Value, e_cm: Value, masses: Value) -> typing.Annotated[list[Value], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    def fast_rambo_massless(self, r: Value, e_cm: Value, p0: Value) -> typing.Annotated[list[Value], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    def fast_rambo_massless_com(self, r: Value, e_cm: Value) -> typing.Annotated[list[Value], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    def function(self) -> Function:
        ...
    def gather(self, index: Value, choices: Value) -> Value:
        ...
    def gather_int(self, index: Value, choices: Value) -> Value:
        ...
    def get_global(self, name: str, dtype: DataType, shape: list[int]) -> Value:
        ...
    def input(self, index: int) -> Value:
        ...
    def input_range(self, start_index: int, end_index: int) -> list[Value]:
        ...
    def interpolate_alpha_s(self, q2: Value, grid_logq2: Value, grid_coeffs: Value) -> Value:
        ...
    def interpolate_pdf(self, x: Value, q2: Value, pid_indices: Value, grid_logx: Value, grid_logq2: Value, grid_coeffs: Value) -> Value:
        ...
    def invariants_from_momenta(self, p_ext: Value, factors: Value) -> Value:
        ...
    def leaky_relu(self, in: Value) -> Value:
        ...
    def matmul(self, x: Value, weight: Value, bias: Value) -> Value:
        ...
    def matrix_element(self, momenta: Value, flavor: Value, mirror: Value, index: Value) -> Value:
        ...
    def matrix_element_multichannel(self, momenta: Value, alpha_s: Value, random: Value, flavor: Value, mirror: Value, index: Value, diagram_count: Value) -> typing.Annotated[list[Value], pybind11_stubgen.typing_ext.FixedSize(5)]:
        ...
    def mul(self, in1: Value, in2: Value) -> Value:
        ...
    def nonzero(self, input: Value) -> Value:
        ...
    def one_hot(self, index: Value, option_count: Value) -> Value:
        ...
    def output(self, index: int, value: Value) -> None:
        ...
    def output_range(self, start_index: int, values: list[Value]) -> None:
        ...
    def permute_momenta(self, momenta: Value, permutations: Value, index: Value) -> Value:
        ...
    def pop(self, in: Value) -> typing.Annotated[list[Value], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    def product(self, values: list[Value]) -> Value:
        ...
    def pt_eta_phi_x(self, p_ext: Value, x1: Value, x2: Value) -> Value:
        ...
    def r_to_x1x2(self, r: Value, s_hat: Value, s_lab: Value) -> typing.Annotated[list[Value], pybind11_stubgen.typing_ext.FixedSize(3)]:
        ...
    def random(self, batch_size: Value, count: Value) -> Value:
        ...
    def reduce_product(self, in: Value) -> Value:
        ...
    def rqs_activation(self, input: Value, bin_count: Value) -> typing.Annotated[list[Value], pybind11_stubgen.typing_ext.FixedSize(3)]:
        ...
    def rqs_find_bin(self, input: Value, in_sizes: Value, out_sizes: Value, derivatives: Value) -> Value:
        ...
    def rqs_forward(self, input: Value, condition: Value) -> typing.Annotated[list[Value], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    def rqs_inverse(self, input: Value, condition: Value) -> typing.Annotated[list[Value], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    def sample_discrete(self, r: Value, option_count: Value) -> typing.Annotated[list[Value], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    def sample_discrete_inverse(self, index: Value, option_count: Value) -> typing.Annotated[list[Value], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    def sample_discrete_probs(self, r: Value, probs: Value) -> typing.Annotated[list[Value], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    def sample_discrete_probs_inverse(self, index: Value, probs: Value) -> typing.Annotated[list[Value], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    def scale_half_transverse_mass(self, momenta: Value) -> Value:
        ...
    def scale_partonic_energy(self, momenta: Value) -> Value:
        ...
    def scale_transverse_energy(self, momenta: Value) -> Value:
        ...
    def scale_transverse_mass(self, momenta: Value) -> Value:
        ...
    def scatter(self, indices: Value, target: Value, source: Value) -> Value:
        ...
    def sde2_channel_weights(self, invariants: Value, masses: Value, widths: Value, indices: Value) -> Value:
        ...
    def select(self, input: Value, indices: Value) -> Value:
        ...
    def softmax(self, input: Value) -> Value:
        ...
    def softmax_prior(self, input: Value, prior: Value) -> Value:
        ...
    def sqrt(self, in: Value) -> Value:
        ...
    def square(self, in: Value) -> Value:
        ...
    def stable_invariant(self, r: Value, mass: Value, s_min: Value, s_max: Value) -> typing.Annotated[list[Value], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    def stable_invariant_inverse(self, s: Value, mass: Value, s_min: Value, s_max: Value) -> typing.Annotated[list[Value], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    def stable_invariant_nu(self, r: Value, mass: Value, nu: Value, s_min: Value, s_max: Value) -> typing.Annotated[list[Value], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    def stable_invariant_nu_inverse(self, s: Value, mass: Value, nu: Value, s_min: Value, s_max: Value) -> typing.Annotated[list[Value], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    def stack(self, args: list[Value]) -> Value:
        ...
    def sub(self, in1: Value, in2: Value) -> Value:
        ...
    def t_inv_min_max(self, pa: Value, pb: Value, m1: Value, m2: Value) -> typing.Annotated[list[Value], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    def two_particle_decay(self, r_phi: Value, r_cos_theta: Value, m0: Value, m1: Value, m2: Value, p0: Value) -> typing.Annotated[list[Value], pybind11_stubgen.typing_ext.FixedSize(3)]:
        ...
    def two_particle_decay_com(self, r_phi: Value, r_cos_theta: Value, m0: Value, m1: Value, m2: Value) -> typing.Annotated[list[Value], pybind11_stubgen.typing_ext.FixedSize(3)]:
        ...
    def two_particle_scattering(self, r_phi: Value, pa: Value, pb: Value, t: Value, m1: Value, m2: Value) -> typing.Annotated[list[Value], pybind11_stubgen.typing_ext.FixedSize(3)]:
        ...
    def two_particle_scattering_com(self, r_phi: Value, pa: Value, pb: Value, t: Value, m1: Value, m2: Value) -> typing.Annotated[list[Value], pybind11_stubgen.typing_ext.FixedSize(3)]:
        ...
    def uniform_invariant(self, r: Value, s_min: Value, s_max: Value) -> typing.Annotated[list[Value], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    def uniform_invariant_inverse(self, s: Value, s_min: Value, s_max: Value) -> typing.Annotated[list[Value], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    def unstack(self, in: Value) -> list[Value]:
        ...
    def unweight(self, weights: Value, max_weight: Value) -> typing.Annotated[list[Value], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    def vegas_forward(self, input: Value, grid: Value) -> typing.Annotated[list[Value], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    def vegas_inverse(self, input: Value, grid: Value) -> typing.Annotated[list[Value], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    def x1x2_to_r(self, x1: Value, x2: Value, s_lab: Value) -> typing.Annotated[list[Value], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
class FunctionGenerator:
    def __call__(self, *args):
        ...
    def __init__(self, arg_types: list[Type], return_types: list[Type]) -> None:
        ...
    def build_function(self, builder: FunctionBuilder, args: list[Value]) -> list[Value]:
        ...
    def function(self) -> Function:
        ...
class FunctionRuntime:
    @typing.overload
    def __init__(self, function: Function) -> None:
        ...
    @typing.overload
    def __init__(self, function: Function, context: Context) -> None:
        ...
    def call(self, arg0: list[typing.Any]) -> list[Tensor]:
        ...
    def call_backward(self, arg0: list[typing.Any], arg1: list[typing.Any], arg2: list[bool]) -> tuple[list[Tensor | None], list[tuple[str, Tensor | None]]]:
        ...
    def call_with_grad(self, arg0: list[typing.Any], arg1: list[bool]) -> tuple[list[Tensor], list[Tensor | None], list[bool]]:
        ...
class Instruction:
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def opcode(self) -> int:
        ...
class InstructionCall:
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    @property
    def inputs(self) -> list[Value]:
        ...
    @property
    def instruction(self) -> Instruction:
        ...
    @property
    def outputs(self) -> list[Value]:
        ...
class Integrand(FunctionGenerator):
    return_momenta: typing.ClassVar[int] = 4
    return_random: typing.ClassVar[int] = 16
    return_x1_x2: typing.ClassVar[int] = 8
    sample: typing.ClassVar[int] = 1
    unweight: typing.ClassVar[int] = 2
    def __init__(self, mapping: PhaseSpaceMapping, diff_xs: DifferentialCrossSection, adaptive_map: None | VegasMapping | Flow = None, discrete_before: None | DiscreteSampler | DiscreteFlow = None, discrete_after: None | DiscreteSampler | DiscreteFlow = None, pdf_grid: PdfGrid | None = None, energy_scale: EnergyScale | None = None, prop_chan_weights: PropagatorChannelWeights | None = None, chan_weight_net: ChannelWeightNetwork | None = None, flags: int = 0, channel_indices: list[int] = []) -> None:
        ...
    def flags(self) -> int:
        ...
    def particle_count(self) -> int:
        ...
class Invariant(Mapping):
    def __init__(self, nu: float = 0.0, mass: float = 0.0, width: float = 0.0) -> None:
        ...
class LineRef:
    def __init__(self, str: str) -> None:
        ...
    def __repr__(self) -> str:
        ...
class Luminosity(Mapping):
    def __init__(self, s_lab: float, s_hat_min: float, s_hat_max: float = 0.0, nu: float = 0.0, mass: float = 0.0, width: float = 0.0) -> None:
        ...
class MLP(FunctionGenerator):
    class Activation:
        """
        Members:
        
          leaky_relu
        
          linear
        """
        __members__: typing.ClassVar[dict[str, MLP.Activation]]  # value = {'leaky_relu': <Activation.leaky_relu: 0>, 'linear': <Activation.linear: 1>}
        leaky_relu: typing.ClassVar[MLP.Activation]  # value = <Activation.leaky_relu: 0>
        linear: typing.ClassVar[MLP.Activation]  # value = <Activation.linear: 1>
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    leaky_relu: typing.ClassVar[MLP.Activation]  # value = <Activation.leaky_relu: 0>
    linear: typing.ClassVar[MLP.Activation]  # value = <Activation.linear: 1>
    def __init__(self, input_dim: int, output_dim: int, hidden_dim: int = 32, layers: int = 3, activation: MLP.Activation = MLP.Activation.Activation.leaky_relu, prefix: str = '') -> None:
        ...
    def initialize_globals(self, context: Context) -> None:
        ...
    def input_dim(self) -> int:
        ...
    def output_dim(self) -> int:
        ...
class Mapping:
    def build_forward(self, builder: FunctionBuilder, inputs: list[Value], conditions: list[Value]) -> tuple[list[Value], Value]:
        ...
    def build_inverse(self, builder: FunctionBuilder, inputs: list[Value], conditions: list[Value]) -> tuple[list[Value], Value]:
        ...
    def forward_function(self) -> Function:
        ...
    def inverse_function(self) -> Function:
        ...
    def map_forward(self, inputs, conditions = list()):
        ...
    def map_inverse(self, inputs, conditions = list()):
        ...
class MatrixElement(FunctionGenerator):
    def __init__(self, matrix_element_index: int, particle_count: int, simple_matrix_element: bool = True, channel_count: int = 1, amp2_remap: list[int] = []) -> None:
        ...
    def channel_count(self) -> int:
        ...
    def particle_count(self) -> int:
        ...
class MatrixElementApi:
    def __init__(self, file: str, param_card: str) -> None:
        ...
    def diagram_count(self) -> int:
        ...
    def helicity_count(self) -> int:
        ...
    def on_gpu(self) -> bool:
        ...
    def particle_count(self) -> int:
        ...
class MomentumPreprocessing(FunctionGenerator):
    def __init__(self, particle_count: int) -> None:
        ...
    def output_dim(self) -> int:
        ...
class MultiChannelMapping(Mapping):
    def __init__(self, mappings: list[PhaseSpaceMapping]) -> None:
        ...
class PartonDensity(FunctionGenerator):
    def __init__(self, grid: PdfGrid, pids: list[int], dynamic_pid: bool = False, prefix: str = '') -> None:
        ...
    def initialize_globals(self, context: Context, pdf_grid: PdfGrid) -> None:
        ...
class PdfGrid:
    def __init__(self, file: str) -> None:
        ...
    def coefficients_shape(self, batch_dim: bool = False) -> list[int]:
        ...
    def logq2_shape(self, batch_dim: bool = False) -> list[int]:
        ...
    def logx_shape(self, batch_dim: bool = False) -> list[int]:
        ...
    @property
    def grid_point_count(self) -> int:
        ...
    @property
    def logq2(self) -> list[float]:
        ...
    @property
    def logx(self) -> list[float]:
        ...
    @property
    def pids(self) -> list[int]:
        ...
    @property
    def q(self) -> list[float]:
        ...
    @property
    def q_count(self) -> int:
        ...
    @property
    def region_sizes(self) -> list[int]:
        ...
    @property
    def values(self) -> list[list[float]]:
        ...
    @property
    def x(self) -> list[float]:
        ...
class PhaseSpaceMapping(Mapping):
    class TChannelMode:
        """
        Members:
        
          propagator
        
          rambo
        
          chili
        """
        __members__: typing.ClassVar[dict[str, PhaseSpaceMapping.TChannelMode]]  # value = {'propagator': <TChannelMode.propagator: 0>, 'rambo': <TChannelMode.rambo: 1>, 'chili': <TChannelMode.chili: 2>}
        chili: typing.ClassVar[PhaseSpaceMapping.TChannelMode]  # value = <TChannelMode.chili: 2>
        propagator: typing.ClassVar[PhaseSpaceMapping.TChannelMode]  # value = <TChannelMode.propagator: 0>
        rambo: typing.ClassVar[PhaseSpaceMapping.TChannelMode]  # value = <TChannelMode.rambo: 1>
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    chili: typing.ClassVar[PhaseSpaceMapping.TChannelMode]  # value = <TChannelMode.chili: 2>
    propagator: typing.ClassVar[PhaseSpaceMapping.TChannelMode]  # value = <TChannelMode.propagator: 0>
    rambo: typing.ClassVar[PhaseSpaceMapping.TChannelMode]  # value = <TChannelMode.rambo: 1>
    @typing.overload
    def __init__(self, topology: Topology, s_lab: float, leptonic: bool = False, nu: float = 0.8, t_channel_mode: PhaseSpaceMapping.TChannelMode = PhaseSpaceMapping.TChannelMode.TChannelMode.propagator, cuts: Cuts | None = None, permutations: list[list[int]] = []) -> None:
        ...
    @typing.overload
    def __init__(self, masses: list[float], s_lab: float, leptonic: bool = False, nu: float = 0.8, mode: PhaseSpaceMapping.TChannelMode = PhaseSpaceMapping.TChannelMode.TChannelMode.rambo, cuts: Cuts | None = None) -> None:
        ...
    def particle_count(self) -> int:
        ...
    def random_dim(self) -> int:
        ...
class Propagator:
    def __init__(self, mass: float = 0.0, width: float = 0.0, integration_order: int = 0) -> None:
        ...
    @property
    def integration_order(self) -> int:
        ...
    @property
    def mass(self) -> float:
        ...
    @property
    def width(self) -> float:
        ...
class PropagatorChannelWeights(FunctionGenerator):
    def __init__(self, topologies: list[Topology], permutations: list[list[list[int]]], channel_indices: list[list[int]]) -> None:
        ...
class RunningCoupling(FunctionGenerator):
    def __init__(self, grid: AlphaSGrid, prefix: str = '') -> None:
        ...
    def initialize_globals(self, context: Context, grid: AlphaSGrid) -> None:
        ...
class TPropagatorMapping(Mapping):
    def __init__(self, integration_order: list[int], nu: float = 0.0) -> None:
        ...
class Tensor:
    @staticmethod
    def numpy(tensor):
        ...
    @staticmethod
    def torch(tensor):
        ...
    def __dlpack__(self, stream: int | None = None, max_version: tuple[int, int] | None = None, dl_device: int | None = None, copy: bool | None = None) -> typing.Any:
        ...
    def __dlpack_device__(self) -> tuple[int, int]:
        ...
class Topology:
    def __init__(self, diagram: Diagram) -> None:
        ...
    def propagator_momentum_terms(self) -> list[tuple[list[int], float, float]]:
        ...
    @property
    def decay_integration_order(self) -> list[int]:
        ...
    @property
    def decays(self) -> list[Decay]:
        ...
    @property
    def incoming_masses(self) -> list[float]:
        ...
    @property
    def outgoing_indices(self) -> list[int]:
        ...
    @property
    def outgoing_masses(self) -> list[float]:
        ...
    @property
    def t_integration_order(self) -> list[int]:
        ...
    @property
    def t_propagator_count(self) -> int:
        ...
    @property
    def t_propagator_masses(self) -> list[float]:
        ...
    @property
    def t_propagator_widths(self) -> list[float]:
        ...
class TwoParticleDecay(Mapping):
    def __init__(self, com: bool) -> None:
        ...
class TwoParticleScattering(Mapping):
    def __init__(self, com: bool, nu: float = 0.0, mass: float = 0.0, width: float = 0.0) -> None:
        ...
class Type:
    @typing.overload
    def __init__(self, dtype: DataType, batch_size: BatchSize, shape: list[int]) -> None:
        ...
    @typing.overload
    def __init__(self, batch_size_list: list[BatchSize]) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    @property
    def batch_size(self) -> BatchSize:
        ...
    @property
    def dtype(self) -> DataType:
        ...
    @property
    def shape(self) -> list[int]:
        ...
class Unweighter(FunctionGenerator):
    def __init__(self, types: list[Type], particle_count: int) -> None:
        ...
class Value:
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: float) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    @property
    def literal_value(self) -> int | float | tuple[list[int], list[int] | list[float]] | None:
        ...
    @property
    def local_index(self) -> int:
        ...
    @property
    def type(self) -> Type:
        ...
class VegasGridOptimizer:
    def __init__(self, context: Context, grid_name: str, damping: float) -> None:
        ...
    def optimize(self, weights: typing.Any, inputs: typing.Any) -> None:
        ...
class VegasMapping(Mapping):
    def __init__(self, dimension: int, bin_count: int, prefix: str = '') -> None:
        ...
    def grid_name(self) -> str:
        ...
    def initialize_global(self, context: Context) -> None:
        ...
def cpu_device() -> Device:
    ...
def cuda_device() -> Device:
    ...
def default_context() -> Context:
    ...
def default_cuda_context() -> Context:
    ...
def format_progress(progress: float, width: int) -> str:
    ...
def format_si_prefix(value: float) -> str:
    ...
def format_with_error(value: float, error: float) -> str:
    ...
def initialize_vegas_grid(context: Context, grid_name: str) -> None:
    ...
def set_lib_path(lib_path: str) -> None:
    ...
def set_thread_count(new_count: int) -> None:
    ...
batch_float: Type  # value = float[batch_size]
batch_four_vec: Type  # value = float[batch_size, 4]
batch_int: Type  # value = int[batch_size]
batch_size: BatchSize  # value = batch_size
batch_sizes: DataType  # value = <DataType.batch_sizes: 2>
float: DataType  # value = <DataType.float: 1>
int: DataType  # value = <DataType.int: 0>
single_float: Type  # value = float[1]
single_int: Type  # value = int[1]
